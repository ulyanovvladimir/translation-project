<!--- Copyright (C) 2009-2015 Typesafe Inc. <http://www.typesafe.com> -->
# HTTP маршрутизация

## Встроенный HTTP маршрутизатор

Маршрутизатор - это компонент, который переводит каждый входящий HTTP запрос в вызов action-а (публичного метода в классе контроллера).

HTTP запрос видится как событие в MVC фреймворке. Это событие содержит два главных кусочка информации:

- путь запроса (такой как `/clients/1542`, `/photos/list`), включая строку запроса.
- HTTP метод (GET, POST, ...).

Маршруты определяются в файле `conf/routes`, который компилируется. Это означает, что вы видите ошибку выбора маршрута прямо в браузере:

[[images/routesError.png]]

## Внедрение зависимостей

Play поддерживает генерацию двух типов маршрутизаторов, один - маршрутизатор, внедренные через зависимости, другой - статический маршрутизатор. По-умолчанию используется статический маршрутизатор, но если вы создадите новое приложение Play, шаблоны Play seed Activator, ваш проект будет включать следующую конфигурацию в `build.sbt` указывая системе сборки использовать внедренный маршрутизатор:

```scala
routesGenerator := InjectedRoutesGenerator
```

Эти примеры кода в документации Play-я подразумевают, что вы используете внедренный генератор маршрутов. Если вы это не используете, вы можете тривиальным образом адаптировать примеры кода к генератору статических маршрутов, либо с помощью префиксов в части вызова контроллеров маршрута с помощью символа `@`, либо с помощью объявления каждого action-метода как `static`.

## Синтаксис файла маршрутов

`conf/routes`  - это конфигурационный файл, используемый маршрутизатором. Этот файл фсодержит список всех маршрутов, необходимых приложению. Каждый маршрут состоит из HTTP метода и URI паттерна, ассоциированного с вызовом action-метода.

Давайте рассмотрим, на что похоже определение маршрута:

@[clients-show](code/javaguide.http.routing.routes)

> Обратите внимание, что в вызове action-а тип параметра идет после имени параметра, как в Scala.

Каждый маршрут начинается с HTTP метода, за которым следуюет URI паттерн. Последний элемент маршрута - определение вызова.

Вы также можете добавлять комментарий к файлу маршрутов с помощью символа `#`:

@[clients-show-comment](code/javaguide.http.routing.routes)

## HTTP метод

HTTP метод может одним из корректных методов, поддерживаемых HTTP (`GET`, `PATCH`, `POST`, `PUT`, `DELETE`, `HEAD`).

## URI паттерн

URI паттерн определяет путь запроса для маршрута. Некоторые части пути запроса могут быть динамическими.

### Статический путь

Например, чтобы точно соответствовать входящему запросу `GET /clients/all` вы можете определить следующий маршрут:

@[static-path](code/javaguide.http.routing.routes)

### Динамические части 

Если вы хотите определить маршрут, который, скажим получает клиента по id, вам нужно добавить динамическую часть:

@[clients-show](code/javaguide.http.routing.routes)

> Обратите внимание, что URI паттерн может содержать более одной динамической части.

Стратегия сопоставлния динамической части по-умолчанию определяется регулярным выражением `[^/]+`, означая что динамическая часть определенная как `:id` будет соответствовать в точности одному сегменту пути URI.

### Динамические части, объединяющие несколько /

Если вы хотите, чтобы динамическая часть захватывала более одного сегмента пути URI, разделенного прямыми слешами, вы можете определить динамическую часть с помощью синтаксиса `*id` , который использует регулярное выражение `.*`:

@[spanning-path](code/javaguide.http.routing.routes)

Здесь для запроса `GET /files/images/logo.png`, динамическая часть `name` будет захватывать значение `images/logo.png`.

### Динамические части с определенным регулярным выражением

Вы также можете определить свое собственное регулярное выражение для динамическай части, используя синтаксис `$id<regex>`:
    
@[regex-path](code/javaguide.http.routing.routes)

## Вызов метода генерации action-а

Последняя часть определения маршрута - это вызов. Эта часть должна определять корректный вызов метода action-а.

Если метод не определяет никаких параметров, просто передайте полное имя метода:

@[home-page](code/javaguide.http.routing.routes)

Если action-метод определяет параметры, соответствующие значения параметров будут искаться в URI запроса, либо из самого пути, либо из строки запроса.

@[page](code/javaguide.http.routing.routes)

Или:

@[page](code/javaguide.http.routing.query.routes)

Здесь определение соответствующего метода `show` в контроллере `controllers.Application` :

@[show-page-action](code/javaguide/http/routing/controllers/Application.java)

### Типы параметров

Для параметров типа `String`, тип параметра необязателен. Если вы хотите чтобы Play трансформировал входящий параметр в специфичный тип Scala, вы можете добавить явный тип:

@[clients-show](code/javaguide.http.routing.routes)

Затем используйте тот же тип для соответствующего параметра action-метода в контроллере:

@[clients-show-action](code/javaguide/http/routing/controllers/Clients.java)

> **Обратите внимание:** Типы параметров определяются с помощью суффиксного синтаксиса. Также, дженерик типы определяются с помощью символов `[]` вместо `<>`, как в Java. Например, `List[String]`  - тот же тип как в Java `List<String>`.

### Параметры с фиксированными значениями

Иногда вам нужно использовать фиксированные значения параметров:

@[page](code/javaguide.http.routing.fixed.routes)

### Параметры со значениями по умолчанию

Вы также можете предоставить значение по умолчанию, которое будет использоваться, если во входящем запросе не найдено никакого значения:

@[clients](code/javaguide.http.routing.defaultvalue.routes)

### Необязательный параметр

Вы также можете определить необязательный параметр, который не обязательно должен присутствовать во всех запросах:

@[optional](code/javaguide.http.routing.routes)

## Приоритеты маршрутов

Много маршрутов могут соответствовать одному и тому же запросу. Если есть конфликт, используется первый маршрут (в порядке объявления).

## Обратная маршрутизация

Маршрутизатор может быть использован для генерации URL из Java вызова. Это делает возможным централизовать все ваши URI паттерны в одном конфигурационном файле, так что вы можете быть уверены при рефакторинге вашего приложения.

Для каждого контроллера, используемого в файле маршрутов, маршрутизатор будет генерировать реверсный контроллер в пакете `routes`, имеющий те же action-методы, с той же сигнатурой, но возвращающий `play.mvc.Call` вместо `play.mvc.Result`. 

`play.mvc.Call` определяет вызов HTTP, и предоставляет и HTTP метод и URI.

Например, если вы создаете контролер вроде:

@[controller](code/javaguide/http/routing/reverse/controllers/Application.java)

И если вы отображаете ео в файле `conf/routes`:

@[hello](code/javaguide.http.routing.reverse.routes)

Вы можете получить реверсный URL к action-методу `hello`, используя `controllers.routes.Application` реверсный контроллер:

@[reverse-redirect](code/javaguide/http/routing/controllers/Application.java)

> **Обратите внимание:** Для каждого пакета контроллера есть подпакет `routes`. Поэтому action `controllers.admin.Application.hello` может быть реверсирован через `controllers.admin.routes.Application.hello`.
