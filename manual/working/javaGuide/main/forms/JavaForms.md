<!--- Copyright (C) 2009-2015 Typesafe Inc. <http://www.typesafe.com> -->
# Обработка отправки формы

Прежде чем вы начнете работать с формами Play, прочтите документацию на [[Play enhancer|PlayEnhancer]]. Play enhancer генерирует методы доступа к полям в Java классах, так что вам не нужно генерировать их самостоятельно. Вы можете решить использовать его для удобства. Все нижеприведенные примеры демонстрируют ручное написание методов доступа к полям ваших классов.

## Определение формы

Пакет `play.data` содержит различные хелперы для обработки и валидации данных отправленной по HTTP формы. Самый простой способ обработать форму - это определить `play.data.Form` который является оберткой над существующим классом:

@[user](code/javaguide/forms/u1/User.java)

@[create](code/javaguide/forms/JavaForms.java)

> **Обратите внимание:** Связывание производится засчет [Spring data binder](https://docs.spring.io/spring/docs/3.0.x/reference/validation.html).

Эта форма может сгенерировть итоговое значение типа `User` из данных мэпа `HashMap<String,String>`:

@[bind](code/javaguide/forms/JavaForms.java)

Если вам пришел запрос, то вы можете организовать связывание непосредственно с содержимым запроса:

@[bind-from-request](code/javaguide/forms/JavaForms.java)

## Определение ограничений

Вы можете определить дополнительные ограничения, которые будут проверятся в течение фазы связывания с помощью JSR-303 (Bean Validation) аннотаций:

@[user](code/javaguide/forms/u2/User.java)

> **Подсказка:** Класс `play.data.validation.Constraints` содержит различные встроенные аннотации для валидации.

Вы также можете определить произвольную валидацию форму с помощью добавления метода `validate` в ваш объект верхнего уровня:

@[user](code/javaguide/forms/u3/User.java)

Сообщение, которое возвращается в вышеприведенном примере будет будет рассматриваться как сообщение об ошибке.

Метод `validate` может вернуть значения следующих типов: `String`, `List<ValidationError>` или `Map<String,List<ValidationError>>`

Метод `validate` вызывается после проверки ограничений, базирующихся на аннотациях и только если они проходят. Если валидация проходит, вы должны вернуть `null`. Возврат любого не-`null` значения (пустой строки или пустого списка) рассматривается как провал валидации.

`List<ValidationError>` может быть полезен, когда у вас есть дополнительная валидация для полей. Например:

@[list-validate](code/javaguide/forms/JavaForms.java)

Использование `Map<String,List<ValidationError>>` похоже на `List<ValidationError>` где ключами мэпа являются коды ошибок вроде `email` в вышеприведенном примере.

## Обработка ошибок валидации

Конечно, вы можете определить ограничения, затем вам нужна возможность обработать ошибки валидации.

@[handle-errors](code/javaguide/forms/JavaForms.java)

Обычно, как показано выше, форму просто передаем в шалон. Глобальные ошибки могут быть отрендерены следующим образом:

@[global-errors](code/javaguide/forms/view.scala.html)

Ошибки для отельного поля могут быть отрендерены в следующей манере:

@[field-errors](code/javaguide/forms/view.scala.html)


## Заполнение формы с начальным значением полей

Иногда вам потребуется заполнить форму существующими значниями, обычно это происходит в случае редактирования:

@[fill](code/javaguide/forms/JavaForms.java)

> **Подсказка:** Объекты `Form` неизменяемые - вызовы таких методов как `bind()` и `fill()` вернут новый объект, заполненный новыми данными.

## Обработка формы, которая не связана с Моделью

Вы можете использовать `DynamicForm`, если вам необходимо получить данные из html-формы, которая не связана с `Model`:

@[dynamic](code/javaguide/forms/JavaForms.java)

## Зарегистрируйте особый DataBinder

В случае если вы хотите определить отображение из особого объекта в строку поля формы и наоборот, вам потребуется зарегистрировать новый Formatter для этого объекта.
Для объектов типа  JodaTime-овых `LocalTime` это может быть реализовано так:

@[register-formatter](code/javaguide/forms/JavaForms.java)

Когда валидация проваливается, создается массив ключей ошибок, будет использован первый ключ, определенный в файле сообщений. Этот массив обычно будет содержать:

    ["error.invalid.<fieldName>", "error.invalid.<type>", "error.invalid"]

Ключи ошибок создаются с помощью [Spring DefaultMessageCodesResolver](http://static.springsource.org/spring/docs/3.0.7.RELEASE/javadoc-api/org/springframework/validation/DefaultMessageCodesResolver.html), где корень "typeMismatch" заменен на "error.invalid".
